---
title: 二叉树的遍历
date: 2020-09-02 09:43:27
categories: Blogs
tags: [数据结构]
---
## 概念
二叉树（binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树。<!--more-->
![二叉树展示图](/img/二叉树的遍历/1.png)
二叉树有四种主要的遍历方式：
* 前序遍历：根节点 -> 左子树 -> 右子树
* 中序遍历：左子树 -> 根节点 -> 右子树
* 后序遍历：左子树 -> 右子树 -> 根节点
* 层级遍历：第一层 -> 第二层 -> 第三层

以上面二叉树图片为例，遍历顺序为：
* 前序遍历：[A, B, D, E, C, F, G]
* 中序遍历：[D, B, E, A, F, C, G]
* 后序遍历：[D, E, B, F, G, C, A]
* 层级遍历：[A, B, C, D, E, F, G]

## 代码实现
### 前序遍历
1.递归
```typescript
interface TreeNode {
  val: number,
  left: TreeNode,
  right: TreeNode,
}

let list: TreeNode[] = [];
function preOrderRecursion(node: TreeNode): void{
  if(node !== null){
    list.push(node);
    preOrderRecursion(node.left);
    preOrderRecursion(node.right);
  }
}
console.dir(list)
```
2.迭代
```typescript
function preOrderIteration(root: TreeNode): TreeNode[]{
  let list: TreeNode[] = [];
  let stack: TreeNode[] = [root];
  let currentNode: TreeNode = root;
  while(currentNode !== null || stack.length){
    if(currentNode !== null){
      list.push(currentNode);
      stack.push(currentNode);
      currentNode = currentNode.left;
    }else{
      currentNode = stack.pop();
      currentNode = currentNode.right;
    }
  }

  return list;
}
```

### 中序遍历
1.递归
```typescript
let list: TreeNode[] = [];
function cenOrderRecursion(node: TreeNode): void{
  if(node !== null){
    cenOrderRecursion(node.left);
    list.push(node);
    cenOrderRecursion(node.right);
  }
}
console.dir(list)
```
2.迭代
```typescript
function cenOrderIteration(root: TreeNode): TreeNode[]{
  let list: TreeNode[] = [];
  let stack: TreeNode[] = [root];
  let currentNode: TreeNode = root;
  while(currentNode !== null || stack.length){
    if(currentNode !== null){
      stack.push(currentNode);
      currentNode = currentNode.left;
    }else{
      currentNode = stack.pop();
      list.push(currentNode);
      currentNode = currentNode.right;
    }
  }

  return list;
}
```

### 后序遍历
1.递归
```typescript
let list: TreeNode[] = [];
function aftOrderRecursion(node: TreeNode): void{
  if(node !== null){
    aftOrderRecursion(node.left);
    aftOrderRecursion(node.right);
    list.push(node);
  }
}
console.dir(list)
```
2.迭代
```typescript
function aftOrderIteration(root: TreeNode): TreeNode[]{
  let list: TreeNode[] = [];
  let stack: TreeNode[] = [];
  let currentNode: TreeNode = root;
  let last: TreeNode = null;
  while(currentNode !== null || stack.length){
    while(currentNode !== null){ // 把当前节点的所有左子节点压入栈
      stack.push(currentNode);
      currentNode = currentNode.left;
    }
    currentNode = stack[stack.length-1];
    if(currentNode.right === null || currentNode.right === last){
      list.push(currentNode);
      stack.pop();
      last = currentNode;
      currentNode = null; // 进入这里为右节点和父节点，置为空后不会继续讲遍历过的节点重复压入栈
    }else{
      currentNode = currentNode.right; // 转向
    }
  }

  return list;
}
```

### 层级遍历
```typescript
function layerIteration(root: TreeNode): TreeNode[]{
  let list: TreeNode[] = [];
  let queue: TreeNode[] = [root];
  while(queue.length){
    let currentNode = queue.shift();
    list.push(currentNode);
    if(currentNode.left){
      queue.push(currentNode.left);
    }
    if(currentNode.right){
      queue.push(currentNode.right);
    }
  };
}
```