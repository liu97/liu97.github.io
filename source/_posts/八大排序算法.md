---
title: 排序算法
date: 2018-04-16 17:10:01
categories: 随笔
tags: [算法]
---
排序在程序中经常见，当然js有一个内置排序函数**sort()**,但是一种排序算法很难在任何情况下都最适合，所以今天我们来学习几种排序算法<!--more-->
## 1.直接选择排序
**排序原理：**
每次从待排序列中选取最大(或最小)的值放在待排序列的最前位置，最终当待排序列长度为1时排序结束。

**时间复杂度：**
总的比较次数N=(n-1)+(n-2)+...+1=n\*(n-1)/2。时间复杂度为O(n2)。

**代码实现：**
```javascript
let arr = [3,4,5,6,1,2,7,9,8];
function select_sort(arr){
	let min_num,index;  //每趟最小值及最小值index
	for (let i = 0; i < arr.length; i++) {
		min_num = arr[i];
		index = i;
		for (let j = i+1; j < arr.length; j++){
			if(arr[j] < min_num){
				min_num = arr[j];
				index = j;
			}
		}
		if(index != i){ //如果存在比目标值小的，交换arr[i]和arr[index]的值
			arr[i] ^= arr[index];
			arr[index] ^= arr[i];
			arr[i] ^= arr[index];
		}
	}
}
select_sort(arr);
```
## 2.堆排序
**排序原理：**
将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

**时间复杂度：**
它的最坏，最好，平均时间复杂度均为O(nlogn)

**代码实现：**
```javascript
let arr = [3,4,5,6,1,2,7,9,8];
function adjust_heap(arr, index, length){  
	let tmp = arr[index];
	for (let i = index*2+1; i < length; i = i*2+1){
		if(arr[i] < arr[i+1] && i+1 < length){
			i++;
		}
		if(arr[i] > tmp){
			arr[index] = arr[i]; //这里不交换，只是将大值往上提，循环结束后将tmp赋给空位
			index = i;
		}
		else{
			break;
		}
	}
	arr[index] = tmp;
}
function swap(arr,a ,b){ // 交换值
	if(arr[a] != arr[b]){
		arr[a] ^= arr[b];
		arr[b] ^= arr[a];
		arr[a] ^= arr[b]
	}
}
function heap_sort(arr){//堆排序
	//从堆的最后一个非叶子节点开始构建大顶堆 
	for (let i = Math.floor(arr.length/2)-1; i >= 0; i--){
		adjust_heap(arr, i, arr.length);
	}
	// 循环之后数组为一个完整的大顶堆，开始排序
	for (let i = 1; i < arr.length; i++) {
		swap(arr, 0, arr.length-i)
		adjust_heap(arr, 0, arr.length-i);
	}
}
heap_sort(arr);
```
## 3.冒泡排序
**排序原理：**
对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。

**时间复杂度：**
采用改进后的冒泡排序算法，只需循环一次就行了，此时是最优时间复杂度：O(n)，若给定的是倒序，此时是最差时间复杂度：O(n2) ，因此综合平均时间复杂度为：O(n2)

**代码实现：**
根据冒泡最初原理实现代码：
```javascript
let arr = [3,4,5,6,1,2,7,9,8];
function bubble_sort(arr) {
	for (let i = 0; i < arr.length; i++) {
		for (let j = 0; j < arr.length-i; j++) {
			if(arr[j] > arr[j+1]){
				let tmp = arr[j];
				arr[j] = arr[j+1];
				arr[j+1] = tmp;
			}
		}
	}
}
bubble_sort(arr);
```
优化：1.加一个标志，如果一次循环中没有交换过元素，则说明已经排好序。2.如果有100个数的数组，仅前面10个无序，后面90个都已排好序且都大于前面10个数字，那么在第一趟遍历后，最后发生交换的位置必定小于10，且这个位置之后的数据必定已经有序了，记录下这位置，第二次只要从数组头部遍历到这个位置就可以了。
```javascript
let arr = [3,4,5,6,1,2,7,9,8];
function bubble_sort(arr)
{
    var j, k;
    var flag = arr.length();
    while (flag > 0)
    {
        k = flag;
        flag = 0;
        for (j = 1; j < k; j++)
            if (a[j - 1] > a[j])
            {
                Swap(a[j - 1], a[j]);
                flag = j;
            }
    }
}
bubble_sort(arr);
```
## 4.直接插入排序
**排序原理：**
每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。

**时间复杂度：**
O(n2)

**代码实现：**
```javascript
let arr = [3,4,5,6,1,2,7,9,8];
function insert_sort(arr){
	for (let i = 0; i < arr.length; i++) {
		let tmp = arr[i];
		for (var j = i-1; j >= 0 && arr[j] > tmp; j--){
			arr[j+1] = arr[j];
		}
		arr[j+1] = tmp;
	}
}
insert_sort(arr);
```

## 5.希尔排序
**排序原理：**
先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。

**时间复杂度：**
希尔排序的时间复杂度取决于步长的选择。
平均情况下，希尔排序的时间复杂度为O(Nlog2N)，最坏情况下为O(N1.5)。

**代码实现：**
```javascript
let arr = [3,4,5,6,1,2,7,9,8,1,2,3,4,5,6];
function shell_sort(arr){
	for (let gap = Math.floor(arr.length/2); gap > 0; gap = Math.floor(gap/2)){
		for (let i = gap; i < arr.length; i++) {
			if(arr[i] < arr[i-gap]){
				let j = i;
				let value = arr[i];
				while(arr[j] < arr[j-gap] && j-gap >= 0){
					arr[j] = arr[j-gap];
					j = j-gap;
				}
				arr[j] = value;
			}
		}
	}
}
```

## 6.快速排序
**排序原理：**
1．先从数列中取出一个数作为基准数。
2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
3．再对左右区间重复第二步，直到各区间只有一个数。

**时间复杂度：**
平均情况下的时间复杂度为O(nlogn)。最坏情况下时间复杂度为O(n2)。

**代码实现：**
```javascript
let arr = [3,4,5,6,1,2,7,9,8,1,2,3,4,5,6];
function swap(arr,a ,b){ // 交换值
	if(arr[a] != arr[b]){
		arr[a] ^= arr[b];
		arr[b] ^= arr[a];
		arr[a] ^= arr[b]
	}
}
function quick_sort(arr){
	quick_sort_recursion(arr, 0, arr.length-1)
}
function quick_sort_recursion(arr, left, right){
	if(left >= right){
		return;
	}
	let tmp = arr[left];
	let i = left;
	let j = right;
	while(i < j){
		while(arr[j] >= tmp && i < j){
			j--;
		}
		while(arr[i] <= tmp && i < j){
			i++;
		}
		swap(arr, i ,j);
	}
	arr[left] = arr[i];
	arr[i] = tmp;
	quick_sort_recursion(arr, left, i-1);
	quick_sort_recursion(arr, j+1, right);
}
```

## 感谢链接
[八大排序算法总结](http://www.cnblogs.com/SnailProgramer/p/4848564.html)