---
title: 浏览器缓存(搬运)
date: 2018-05-06 22:46:02
categories: Blogs
tags: [web缓存]
---
浏览器缓存就是把一个已经请求过的Web资源（如html页面，图片，js，数据等）拷贝一份副本储存在浏览器中。缓存会根据进来的请求保存输出内容的副本。当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。
## 为什么使用缓存
### 1.减少网络带宽消耗
无论对于网站运营者或者用户，带宽都代表着金钱，过多的带宽消耗，只会便宜了网络运营商。当Web缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。

### 2.降低服务器压力
给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。

### 3.减少网络延迟，加快页面打开速度
带宽对于个人网站运营者来说是十分重要，而对于大型的互联网公司来说，可能有时因为钱多而真的不在乎。那Web缓存还有作用吗？答案是肯定的，对于最终用户，缓存的使用能够明显加快页面打开速度，达到更好的体验。

## 浏览器的缓存规则
### 强制缓存
首先，我们先来看一张强制缓存时的时序图，来了解一下强制缓存在不同情况下的请求模式：
![强制缓存时序图](/img/浏览器缓存/1.png)
从图中，我们不难看出，只有当缓存失效时，才会去服务器获取最新资源的方式，就是强制缓存。而在协议层的字段中，可以造成强制缓存的字段有两个Expires和Cache-Control。

**Expires**
最早使用的是Expires字段，该字段表示缓存到期时间，即有效时间+当时服务器的时间，然后将这个时间设置在header中返回给服务器。因此，该时间是一个绝对时间，举例说明：
> Expires: Thu, 10 Nov 2017 08:45:11 GMT

在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。
但是，这个字段设置时有缺点：
由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源，同时，还导致客户端与服务端的时间不一致，致使缓存失效。

**Cache-Control**
已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-Control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求
这两者的区别就是前者是绝对时间，而后者是相对时间。我们不妨举个例子来说明一下：
> Cache-Control: max-age=2592000

Cache-Control的字段可以带的值：
> 1.max-age：即最大有效时间，在上面的例子中我们可以看到
2.no-cache：表示没有缓存，即告诉浏览器该资源并没有设置缓存
3.s-maxage：同max-age，但是仅用于共享缓存，如CDN缓存
4.public：多用户共享缓存，默认设置
5.private：不能够多用户共享，HTTP认证之后，字段会自动转换成private。

自从http1.1开始，Expires逐渐被Cache-Control取代。Cache-Control是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性。如果同时设置的话，其优先级高于Expires。

### 对比缓存
废话不多说，我们也先从对比缓存的时序图讲起，如图：
![对比缓存时序图](/img/浏览器缓存/2.png)
对比缓存的过程是，先从缓存中获取对应的数据标识，然后向服务器发送请求，确认数据是否更新，如果更新，则返回新数据和新缓存；反之，则返回304状态码，告知客户端缓存未更新，可继续使用。
这正好弥补了一些强制缓存的缺陷。对比缓存主要应用于一些时常需要动态更新的资源文件。
对比缓存在协议里的字段是Last-Modified和If-Modified-Since。
**Last-Modified**
Last-Modified：服务器告知客户端，资源最后一次被修改的时间，例如：
> Last-Modified: Thu, 10 Nov 2015 08:45:11 GMT

If-Modified-Since：再次请求时，请求头中带有该字段，服务器会将If-Modified-Since的值与Last-Modified字段进行对比，如果相等，则表示未修改，响应304；反之，则表示修改了，响应200状态码，返回数据。
这个字段可以和Cache-Control配合使用。

但是他还是有一定缺陷的：
> 1.如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
2.如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。

**Etag**
由于Last-modified还是存在缺陷的，尽管大多数情况下，会使用它，但当遇到我们上面所说的场景时，我们可能就需要了解一下，我们另一个小伙伴了——Etag。
Etag存储的是文件的特殊标识(一般都是hash生成的)，服务器存储着文件的Etag字段，可以在与每次客户端传送If-no-match的字段进行比较，如果相等，则表示未修改，响应304；反之，则表示已修改，响应200状态码，返回数据。
最后，通过一张原理图，我们来加深一下记忆：
![etag原理图](/img/浏览器缓存/3.png)

## 浏览器提供的三种刷新方式
> 1.url+enter或者a标签的超链接点击,点击前进后退按钮
2.F5刷新 或者 点击刷新按钮
3.ctrl+F5强制刷新

那么，这三种情况有什么区别呢？
第一种，其实就是我们理想缓存的情况，特别注意一下，如果缓存没有过期，借助于Chrome的Network，我们会发现状态码是200，因为这里并没有向后端发起请求而是直接重现上次请求的结果，所以仍然是200，唯一不同的是他的size栏并不是显示他的大小，而是显示from cache。

第二种，则会直接无视Cache-Control与Expires是否过期，而直接在requset headers中设置Cache-Control: max-age=0,直接向服务器发送请求。
服务器根据If-None-Match和If-Modified-Since进行判断是否过期。大多数情况下，我们对静态资源设置时间比较久，很多没有过期。这时候，我们就会看见许多304(另一种情况是过期后请求得到304)。

第三种，同样直接无视Cache-Control与Expires是否过期，并且设置Cache-Control： no-cache,也不会发送If-None-Match和If-Modified-Since。服务器则必须返回新的资源。

## http请求流程
![http请求流程图](/img/浏览器缓存/4.png)

## 不能缓存的请求：
当然并不是所有请求都能被缓存，无法被浏览器缓存的请求如下：
> 　1. HTTP信息头中包含Cache-Control:no-cache，pragma:no-cache（HTTP1.0），或Cache-Control:max-age=0等告诉浏览器不用缓存的请求
　　　　2. 需要根据Cookie，认证信息等决定输入内容的动态请求是不能被缓存的
　　　　3. 经过HTTPS安全加密的请求（有人也经过测试发现，ie其实在头部加入Cache-Control：max-age信息，firefox在头部加入Cache-Control:Public之后，能够对HTTPS的资源进行缓存，参考《HTTPS的七个误解》）
　　　　4. POST请求无法被缓存
　　　　5. HTTP响应头中不包含Last-Modified/Etag，也不包含Cache-Control/Expires的请求无法被缓存

## 搬运链接
[漫谈Web缓存](https://segmentfault.com/a/1190000006671795)
[浏览器缓存](https://segmentfault.com/a/1190000011212929)
[浏览器缓存机制详解](https://www.cnblogs.com/slly/p/6732749.html)